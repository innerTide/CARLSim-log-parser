"""This is a Python script to parse the log file generated by CARLSim."""

import re
import sys

SEGMENT_LENGHT_LIMITATION = 4

log_file = open('test.log', mode='r')
log_str = log_file.read()

# Parsing Number of input and output neurons


def neuronNumberParser():
    """Return neuron number."""
    number_re = re.compile('\(numN\)\s=\s[0-9]*', flags=0)
    number = number_re.search(log_str)
    number = re.compile('\(numN\)\s=\s', flags=0).sub('', number.group())
    neuron_number = int(number)

    return neuron_number

# Parsing Number of input and output neurons


def neuronLayerParser():
    """Return (input_number, output_number)."""
    input_number_re = re.compile('Group\sinput.*\n[^0-9]+[0-9]+', flags=0)
    input_number = input_number_re.search(log_str)
    input_number = re.compile('Group\sinput.*\n[^0-9]+', flags=0)\
                     .sub('', input_number.group())
    input_number = int(input_number)

    output_number_re = re.compile('Group\soutput.*\n[^0-9]+[0-9]+', flags=0)
    output_number = output_number_re.search(log_str)
    output_number = re.compile('Group\soutput.*\n[^0-9]+', flags=0)\
                      .sub('', output_number.group())
    output_number = int(output_number)

    return input_number, output_number

# Parsing the connection pair list
# The return value is a list [(src_node_id,dst_node_id)].


def connectionPairParser():
    """Return the array of connection pairs."""
    pattern = re.compile('(\[\s*[0-9]+,\s*[0-9]+\]\s(([0-9]|\.)+|nan)\s+\n?)+',
                         flags=0)
    connection_pair_list_str = pattern.search(log_str).group(0)
    connection_pair_list_str = re.compile('\s(nan|([0-9]+\.[0-9]+))\s+',
                                          flags=0)\
                                 .sub(';', connection_pair_list_str).strip()
    connection_pair_list_str = re.compile('\s+', flags=0)\
                                 .sub('', connection_pair_list_str)\
                                 .split(';')
    connection_pair_list_str.pop()
    connection_pair_list = []
    neuron_number = neuronNumberParser()
    input_number, output_number = neuronLayerParser()
    for pair_str in connection_pair_list_str:
        pair_str = re.compile('\[|\]', flags=0).sub('', pair_str).split(',')
        if (int(pair_str[0]) < neuron_number) and\
           (int(pair_str[1])+input_number < neuron_number):
            connection_pair_list.append((int(pair_str[0]),
                                         int(pair_str[1])+input_number))
        else:
            print("Node ID error!!!!")
            sys.exit()
    return connection_pair_list


# Group the input and output neurons to build segments


def segmentGroupBuilder():
    """Return the dictionary of groups, indexed by master."""
    segment_group = {}
    connection_pair_list = connectionPairParser()
    for pair in connection_pair_list:
        
# Generate input number of nodes
# Return value is a list of integer
# The index of the list is corresponding node ID


def inputNumberGenerator():
    """Return the input number of nodes."""
    connection_pair_list = connectionPairParser()
    input_number_list = [0 for n in range(neuronNumberParser())]
    for pair in connection_pair_list:
        input_number_list[pair[1]] = input_number_list[pair[1]] + 1
    return input_number_list


# Parsing the spiking times


def spikingTimeParser(log_str):
    """Return the spiking times of each neuron."""
    first_line_re = '\|\s*[0-9]+\s*\|\s*[0-9]+\.[0-9]+\s*\|([\s]*[0-9]+)+\s+'
    rest_line_re = '(\|\s+\|\s+\|(\s*[0-9]+)+\s+)*'
    pattern = re.compile(first_line_re + rest_line_re, flags=0)
    time_table = pattern.finditer(log_str)
    spiking_time = {}

    for i in time_table:
        time_list = i.group().replace('|', '').strip()
        time_list = re.compile('\s+', flags=0).split(time_list)
        neuron_id = int(time_list.pop(0))
        time_list.pop(0)
        time_list = [int(i) for i in time_list]
        spiking_time[neuron_id] = time_list

    return spiking_time


print(inputNumberGenerator())
log_file.close()
